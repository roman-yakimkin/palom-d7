<?php

/**
 * @file
 * This file is part of Twig For Drupal 7.
 *
 * @author RenÃ© Bakx
 * @co-maintainer Pol Dellaiera
 *
 * @see http://tfd7.rocks for more information
 *
 * @version 7.x-3.x
 */



/**
 * Registers the .tpl.twig extension for twig templates.
 *
 * @return string
 *   The template extension.
 */
function twig_extension()
{
  return '.tpl.twig';
}

/**
 * Implementation of hook_init()
 *
 * Note: called at rebuild registry!
 */
function twig_init($theme)
{

  if (file_exists($file = dirname($theme->filename) . '/template.php')) {
    require_once $file;
  }
}

/**
 * Implementation of hook_theme()
 *
 * Registers both twig and php_template functions and templates
 * which is needed to perform the fallback to .tpl.php.
 */
function twig_theme($existing, $type, $theme, $path)
{
  $templates = drupal_find_theme_functions($existing, array($theme));
  $templates += drupal_find_theme_templates($existing, twig_extension(), $path);
  return $templates;
}

/**
 * Implementation of hook ENGINE_render_template.
 *
 * Checks if the twig template is available or else let drupal fallback to phptemplate.
 *
 * @param string $template
 *   template filename.
 * @param array $variables
 *   variables to be assigned to template.
 *
 * @return <string> rendered template
 */
function twig_render_template($template, $variables = array())
{
  $content = '';

  if (file_exists($template)) {
    try {
      $twig = twig_get_instance();
      $template = $twig->loadTemplate($template);
      $content = $template->render($variables);
    } catch (Exception $e) {
      $content = t('Twig error "!error"', array('!error' => $e->getMessage()));
      die($e->getMessage());
    }
  } else {
    $content = t('Template (!template) not found ', array('!template' => $template));
  }

  return $content;
}

/**
 * Clears the entire template cache folder.
 *
 * Note: This is not a hook because it's not a .module file.
 * This function must be called from another module.
 *
 * @return void
 */
function twig_clear_cache()
{
  twig_get_cache_bin()->deleteAll();
}

/**
 * Returns a singleton version of the twig template engine.
 *
 * @return TFD_Environment
 */
function twig_get_instance()
{
  static $twig_engine;

  if (!is_object($twig_engine)) {
    $twigEnvironment = array();
    $twigEnvironment['autorender'] = (bool)variable_get('twig_auto_render', TRUE);
    $twigEnvironment['autoescape'] = (bool)variable_get('twig_auto_escape', FALSE);
    $twigEnvironment['auto_reload'] = (bool)variable_get('twig_auto_reload', TRUE);
    $twigEnvironment['debug'] = (bool)variable_get('theme_debug', FALSE);

    $twigEnvironment['cache'] = twig_get_cache_bin();


    $loader = new Twig_Loader_Filesystem();
    $theme_names = twig_get_theme_namespaces();
    $loader->addPath(DRUPAL_ROOT);
    foreach ($theme_names as $theme_name => $paths) {
      foreach ($paths as $path) {
        $templatesDirectory = DRUPAL_ROOT . DIRECTORY_SEPARATOR . $path;
        $loader->addPath($templatesDirectory, $theme_name);
      }
    }
    $twig_engine = new TFD_Environment($loader, $twigEnvironment);
    $twig_engine->addExtension(new TFD_Extension());
    drupal_alter('twig_init', $twig_engine);
  }

  return $twig_engine;
}


/**
 * Build the @theme namespace array
 *
 * @return array
 */
function twig_get_theme_namespaces()
{
  $namespaces = &drupal_static(__FUNCTION__, array());
  if (!$namespaces) {
    $available_themes = list_themes();
    $namespaces = array();

    foreach (twig_get_theme_paths() as $theme => $paths) {
      $namespaces[$theme] = $paths;
      $theme_root = dirname($available_themes[$theme]->filename);
      if (!empty($available_themes[$theme]->info['namespaces'])) {
        /** @var array $namespaces */
        $theme_namespaces = $available_themes[$theme]->info['namespaces'];
        foreach ($theme_namespaces as $namespace => $path) {
          $ns_path = implode(DIRECTORY_SEPARATOR,
            array(
              trim($theme_root, DIRECTORY_SEPARATOR),
              trim($path, DIRECTORY_SEPARATOR),
            ));
          $namespaces[$namespace] = array($ns_path => $ns_path);
        }
      }
    }
  }
  return $namespaces;
}

/**
 * Returns an array of theme paths by theme name.
 *
 * @return array  The theme paths keyed by theme name.
 */
function twig_get_theme_paths()
{
  global $theme;
  $available_themes = list_themes();
  $available_themes[$theme]->info += array('base theme' => NULL);
  $theme_paths = array();

  $theme_root = dirname($available_themes[$theme]->filename);
  $theme_paths[$theme] = array($theme_root => $theme_root);
  $theme_paths[$theme] += _twig_get_subdirectories_in($theme_root . '/templates');

  $basethemes = drupal_find_base_themes($available_themes, $theme);
  if (count($basethemes) > 0) {
    foreach (array_keys($basethemes) as $basename) {
      if (isset($available_themes[$basename])) {
        $basetheme_root = dirname($available_themes[$basename]->filename);
        $theme_paths[$basename] = array($basetheme_root => $basetheme_root);
        $theme_paths[$basename] += _twig_get_subdirectories_in($basetheme_root . '/templates');
      }
    }
  }

  return $theme_paths;
}

/**
 * Return the list of sub directories in a directory.
 *
 * TODO: Is there a Drupal core function for this already?
 *
 * @param string $root
 *   The parent directory.
 *
 * @return string[]
 *   The subdirectories.
 */
function _twig_get_subdirectories_in($root)
{
  if (!is_dir($root)) {
    $root = dirname($root);
  }

  $iter = new RecursiveIteratorIterator(
    new RecursiveDirectoryIterator($root, RecursiveDirectoryIterator::SKIP_DOTS),
    RecursiveIteratorIterator::SELF_FIRST,
    RecursiveIteratorIterator::CATCH_GET_CHILD
  );

  $paths = array($root => $root);
  foreach ($iter as $path => $dir) {
    if ($dir->isDir()) {
      $paths[$path] = $path;
    }
  }

  return $paths;
}

/**
 * Tests if it is a writable directory to store the twig cache files in.
 *
 * @param string $scheme
 *   The scheme to validate.
 *
 * @return bool
 *   True is valid, otherwise False.
 */
function twig_cache_scheme_is_valid($scheme)
{
  if (file_stream_wrapper_valid_scheme(file_uri_scheme($scheme))) {
    $scheme = drupal_dirname($scheme);
    if (is_dir($scheme) && is_writable($scheme)) {
      return TRUE;
    }
  }

  return FALSE;
}

/**
 * Get the cache scheme.
 *
 * @return string
 *   The scheme
 */
function twig_get_cache_scheme()
{
  $streamwrappers = file_get_stream_wrappers(STREAM_WRAPPERS_LOCAL_HIDDEN);
  if (isset($streamwrappers['twigcache'])) {
    return 'twigcache://';
  }
}

/**
 * Get the cache bin.
 *
 * @return TFD_Cache_Filesystem
 *   The cache bin.
 *
 * @throws ErrorException
 */
function twig_get_cache_bin()
{
  static $cache_bin;

  if (!is_object($cache_bin)) {
    $cache_scheme = twig_get_cache_scheme();
    list($scheme, $target) = explode('://', $cache_scheme, 2);
    $wrapper = file_stream_wrapper_get_instance_by_scheme($scheme);

    if (!twig_cache_scheme_is_valid($cache_scheme)) {
      $directory = $wrapper->getDirectoryPath();

      $message = t('Could not write in cache directory: @directory', array(
          '@directory' => $directory,
        )
      );

      watchdog('twig', $message, array(), WATCHDOG_ERROR);
      throw new ErrorException($message);
    }

    if ($target) {
      $wrapper->setUri($cache_scheme);
    }

    $cache_bin = new TFD_Cache_Filesystem($wrapper);
  }

  return $cache_bin;
}
